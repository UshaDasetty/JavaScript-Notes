V8 Engine
ECMA Script
Variables 
Data Types
Interpollation
DOM 
Callbacks
Promises
Async await
Classes
Events
Event listeners and Event Target
Event Bubbling and Event Capturing
Fetch API
Array methods
String methods
Objects
Scoping
Hoisting 
Closures
this keyword
'usestrict'
Pop Up boxes 
Console Object methods
Diff between parameters and arguements
IIFE
Local Storage, Session Storage and Cookies
Iterations
new keyword
Errors
Math Operators
Date Operators
Outputs
call(), apply() and bind() methods
prototype

**************************************************************************************************
V8 Engine:-

-> V8 is the name of the Javascript engine which is developed by Google chrome.
-> It is run time environment.
-> It is used to execute JavaScript code while browsing the chrome.
-> Every Browser is having Javascript engine.
     1) V8(chrome)
     2) SpiderMonkey(Firefox)
     3) Rhino(Mozilla)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
ECMA Script:-

-> European Computer Manfactures Association Script).
-> It is also known ECMA-262.
-> First Edition was released in 1997.
-> It is a Scripting language based on JavaScript.
-> Invented by Brendan Eich at NetsScape.
-> ES6 to ES10
-> ES6 Features are:
    1) let keyword
    2) const keyword
    3) Arrow functions
    4) For/of and For/in
    5) Object Destructuring
    6) Promises
    7) Default parameters
    8) Spread Operators
    9) Rest Operators
    10) this keyword
    11) Array methods
    12) Classes

 ---------------------------------------------------------------------------------------------------------------------
 Variables:-

 Variables: Variables are containers for storing data, Always declare Javascript variables with var, let and const keywords.
   
    var -    hoisting        &    mutable
    let -    not Hoisting    &    mutable
    const -  not Hoisting    &    not mutable

---------------------------------------------------------------------------------------------------------------------
DataTypes:-

 DataType: Type of the value assigned.
    1) Primitive types
        - String
        - Number
        - Boolean
        - Undefined
        - Null

    2) Non-primitive types
        - Object
        - Array
        - RegExp

---------------------------------------------------------------------------------------------------------------------
Interpollation: concating string with variable using ` ${}`

            const uid = 'abc123';
            var fullName = 'Usha Dasetty';
            var email = 'usha@gmail.com';
            var password = '123456';
            var confirmPassword = '123456';
            var isLoggedIn = false;

            // Interpollation
            console.log(`
                uid: ${uid}
                fullname: ${fullName}
                email: ${email}
                password: ${password}
            `);

---------------------------------------------------------------------------------------------------------------------
DOM

---------------------------------------------------------------------------------------------------------------------
Callbacks

-> A callback function is a function passed into another function as an argument.
-> A callback function executes after outer function executes.
-> Higher Order function:- A function which receives other function as an argument is called Higher Order Function.

        function greeting(name) {
        alert('Hello ' + name);
        }

        function processUserInput(callback) {
        var name = prompt('Please enter your name.');
        callback(name);
        }

        processUserInput(greeting);

-> In the above example greeting() is a callback function, and processUserInput() is Higher Order Function.
-> greeting() is executed after processUserInput() executes.



Callback Hell :-

-> When we are having nested callbacks is called callback hell.
-> It is difficult to handle callback hell, to overcome this we use promises.

        setTimeout(() => {
            console.log("Hello");
            setTimeout(() => {
                console.log("Hey");
                setTimeout(() => {
                    console.log("Namaste");
                    setTimeout(() => {
                        console.log("Hi");
                        setTimeout(() => {
                            console.log("Bonjour");
                        }, 2000);
                    }, 2000);
                }, 2000);
            }, 2000);
        }, 2000);

---------------------------------------------------------------------------------------------------------------------
Promises

-> Promises are used to handle asynchronous operations in JavaScript. 
-> It is easy to manage when dealing with multiple asynchronous operations, 
    where callbacks can create callback hell leading to unmanageable code. 

-> A Promise has four states: 
    fulfilled: Action related to the promise succeeded.
    rejected: Action related to the promise failed.
    pending: Promise is still pending i.e. not fulfilled or rejected yet.
    settled: Promise has fulfilled or rejected.

-> Parameters:
    - Promise takes two arguments resolve and reject
    - If everything went well then it call resolve().
    - If everything do not go well then it call reject().


        var promise = new Promise(function(resolve, reject) {
        const x = "usha";
        const y = "usha"
        if(x === y) {
            resolve();
        } else {
            reject();
        }
        });

        promise.
            then(function () {
                console.log('Success, You are a usha');
            }).
            catch(function () {
                console.log('Some error has occurred');
            });



Promise Hell :-

-> When we have nested promises i.e., having many then() blocks it is difficult to handle.
-> to overcome this difficult, we Async and await.


        var promise = new Promise(function(resolve, reject) {
            const x = "usha";
            const y = "usha"
            if(x === y) {
                resolve();
            } else {
                reject();
            }
        });

        promise.
            then(function () {
                console.log('Success, You are a usha');
            }).
            then(function () {
                console.log('Welcome usha');
            }).
            then(function () {
                console.log('How are you');
            }).
            catch(function () {
                console.log('Some error has occurred');
            });

---------------------------------------------------------------------------------------------------------------------
Async await

-> It's easier way to write promise.
-> async makes, a function return a Promise.
-> await makes, a function wait for a Promise.
-> The await keyword can only be used inside an async function.


            function resolveAfter2Seconds() {
                return new Promise(resolve => {
                    setTimeout(() => {
                    resolve('resolved');
                    }, 2000);
                });
            }

            async function asyncCall() {
                console.log('calling');
                const result = await resolveAfter2Seconds();
                console.log(result);   // expected output: "resolved"
            }

            asyncCall();

---------------------------------------------------------------------------------------------------------------------
Classes

-> Classes are one of the features introduced in the ES6 version of JavaScript.
-> A class is a blueprint(template) for the object. We can create an object from the class.
-> You can think of the class as a sketch (prototype) of a house. It contains all the details about the floors, doors, windows, etc. 
   Based on these descriptions, you build the house. House is the object.
-> JavaScript class is a special type of function. And the typeof operator returns function for a class.

            class Person {}
            console.log(typeof Person); // function

-> The constructor method is called automatically when a new object is created.
-> Constructor
        - It has to have the exact name "constructor"
        - It is executed automatically when a new object is created
        - It is used to initialize object properties
        - If you do not define a constructor method, JavaScript will add an empty constructor method.


-> Creating JavaScript Class

            // creating a class
            class Person {
            constructor(name) {
                this.name = name;
            }
            }

            // creating an object
            const person1 = new Person('John');
            const person2 = new Person('Jack');

            console.log(person1.name); // John
            console.log(person2.name); // Jack


-> Creating JavaScript Class methods
    - It is easy to define methods in the JavaScript class. You simply give the name of the method followed by ().

            class Person {
                constructor(name) {
                this.name = name;
            }

                // defining method
                greet() {
                    console.log(`Hello ${this.name}`);
                }
            }

            let person1 = new Person('John');

            // accessing property
            console.log(person1.name); // John

            // accessing method
            person1.greet(); // Hello John


-> Getters and Setters
    - In JavaScript, getter methods get the value of an object and setter methods set the value of an object.
    - JavaScript classes may include getters and setters. You use the get keyword for getter methods and set for setter methods.

            class Person {
                constructor(name) {
                    this.name = name;
                }

                // getter
                get personName() {
                    return this.name;
                }

                // setter
                set personName(x) {
                    this.name = x;
                }
            }

            let person2 = new Person('Jack');
            console.log(person2.name); // Jack

            // changing the value of name property
            person2.personName = 'Sarah';
            console.log(person2.name); // Sarah


-> Hoisting
    - A class should be defined before using it. Unlike functions and other JavaScript declarations, the class is not hoisted.
    - accessing a class before defining it throws an error.

            // accessing class
            const p = new Person(); // ReferenceError

            // defining class
            class Person {
            constructor(name) {
                this.name = name;
            }
            }


-> 'use strict'
    - Classes always follow 'use-strict'. All the code inside the class is automatically in strict mode.

            class Person {
            constructor() {
                a = 0;
                this.name = a;
            }
            }

            let q = new Person(); // ReferenceError: a is not defined"

---------------------------------------------------------------------------------------------------------------------
Events

https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events

-> The change in the state of an object is known as an Event.
-> In html, there are various events which represents that some activity is performed by the user or by the browser. 
   When javascript code is included in HTML.
-> The process of reacting over the events is called Event Handling. Thus, js handles the HTML events via Event Handlers.
-> Event Handlers can be used to handle and verify user input, user actions, and browser actions.
-> Some of the HTML events and their event handlers are:

    1) Mouse Events
        - onclick : When mouse click on an element.
        - onmouseover : When the cursor of the mouse comes over the element.
        - onmouseout : When the cursor of the mouse leaves an element.
        - onmousedown : When the mouse button is pressed over the element.
        - onmouseup	: When the mouse button is released over the element.
        - onmousemove : When the mouse movement takes place.

    2) Keyboard Events
        - onkeydown & onkeyup : When the user press and then release the key.

    3) Form Events
        - onfocus : When the user focuses on an element
        - onsubmit : When the user submits the form.
        - onblur : When the focus is away from a form element.
        - onchange : When the user modifies or changes the value of a form element.

    4) Window/Document/Screen Events
        - onload : When the browser finishes the loading of the page.
        - onunload : When the visitor leaves the current webpage, the browser unloads it.
        - onresize : When the visitor resizes the window of the browser.

    5) Click Event
    6) MouseOver Event
    7) Focus Event
    8) Keydown Event
    9) Load event

---------------------------------------------------------------------------------------------------------------------
Event listeners
https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener

-> The addEventListener() method is used to attach an event handler to a particular element.
-> The addEventListener() method is an inbuilt function of JavaScript.


Event Target 
https://developer.mozilla.org/en-US/docs/Web/API/EventTarget

---------------------------------------------------------------------------------------------------------------------
Event Bubbling and Event Capturing

---------------------------------------------------------------------------------------------------------------------
Fetch API
https://www.javascripttutorial.net/javascript-fetch-api/

-> The Fetch API is a modern interface that allows you to make HTTP requests to servers from web browsers.

---------------------------------------------------------------------------------------------------------------------
Array methods

